<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue warn "Property or method index is not defined on the..."]]></title>
    <url>%2F2019%2F01%2F15%2FProperty-or-method-index-is-not-defined-on-the-instance-but-referenced-during-render%2F</url>
    <content type="text"><![CDATA[8月份开始团队使用 React，所以 Vue 很久没接触了，今天同事问我一个问题，发出来记录下 问题重现一个输入键盘，keyUpHandle 为该触发事件函数，绑定 $event 和 index，在输入的时候 index 一直报错，虽然不影响功能实现，但洁癖看到红色报错还是很不爽的，一起来看吧！ 图中看到 “「Property or method index is not defined on the instance but referenced during render」” 报错，翻译过来就是 “属性或方法索引未在实例上定义，但引用了”，打开 Chrome dev，根据报错定位到该行代码 可以看到「 vm.index 」为 undefined 小插曲插段关于 JavaScript 的两个特殊数据类型：undefined 和 null，第一次碰见 undefined 的时候，尝试用 Java if(obj == undefined){ // doSomething... } 自作聪明了，查询后得知 JavaScript 写法是这样的： if(typeof(obj) == “undefined”){ // doSomething... } 这是为什么捏，为什么是这种写法捏，JavaScript 为什么偏偏多出了这种写法？我们知道在大多数计算机语言内，有且仅有一个表示”无”的值， C 是 NULL，Java 是 null，Python 是None，Ruby 是 nil，为什么 JavaScript 表示“无”的值是 undefined 和 null？ JavaScript 诞生之初，Brendan Eich 根据 C 传统设计 null 自动转成 0，但这个在 Java 里是一个对象，由于 JavaScript 数据类型分为「原始类型」和「复合类型」，Eich 觉得 “无” 最好不是一个对象，而且 JavaScript 一开始并没错误处理机制，数据类型不匹配都是直接默认转换或者失败，这样不容易发现错误，从而设计了 undefined。 关于 undefinedundefined 表示未声明或已声明但未赋值的变量或不存在的对象，函数没有返回值时，默认返回 undefined，判断是不是 undefined 使用 typeof 函数，其返回的字符串包括如下： “number”，“string”，“boolean”，“object”，“function”，“undefined” 回到正题，错误提示 index 以声明但未赋值，Vue 里是有关于这段描述的，也是最独特的的特性之一，「非侵入性的响应式系统」，就是深入响应式原理啦～～ 「Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值」，ok，到这里，问题就解决了，既然说了可以声明空值，那就声明一个空值！ data() { return{ index: &#39;&#39; } } 大功告成～ 更多关于「深入响应式原理」的知识请猛点 这里 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 生成目录结构]]></title>
    <url>%2F2018%2F12%2F13%2FMarkdown-%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言 Markdown 作为标记语言可以非常方便的排版以及适用于各大平台的适配，沉浸式的写作体验可以让你专注于写作而不会在排版上，安利一款 mac 极简 Markdown 编辑器 「Typora」 点这里 体验。 什么是 tree最近团队封装组件库，需要编写 README.md，但是没有目录的话阅读代码结构是很困难的，经常性会看见这种 ├── build ├── config ├── docs │ └── static │ ├── css │ └── js ├── src │ ├── assets │ ├── components │ ├── store │ │ └── modules │ └── views │ ├── book │ └── movie └── static 那么这种目录的话其实在 mac 上其实是没有 tree 命令的，不过可以用 find 命令模拟出 tree 命令的效果 $ find . -print | sed -e ``&#39;s;[^/]*/;|____;g;s;____|; |;g&#39; 当然每次这样很麻烦。。，作为程序员，以最简单的数组去重来说我肯定不会用 es5 ，肯定会像这样 [1, 2, 3, 1, 2, 3].filter((el, i, arr) =&gt; i === arr.indexOf(el)); macOS 终端也可快速使用命令，打开 .zshrc 文件，可用 sublime or vscode or 你喜欢的任何软件打开，找到 # Example aliases，新增一行 alias tree=&quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;&quot; 虽然可以显示出 tree 目录，但是无法指定层级，很麻烦 你也可以设置其它的，比如我这样 alias ..=&quot;cd ..&quot; alias ...=&quot;cd ../..&quot; alias ....=&quot;cd ../../..&quot; alias gbr=&quot;git branch&quot; alias gs=&quot;git status&quot; alias pl=&quot;git pull&quot; alias gd=&quot;git diff&quot; alias gco=&quot;git checkout&quot; alias gl=&quot;git log&quot; alias gps=&quot;git push&quot; alias gc=&quot;git clone &quot; alias cls=&quot;clear&quot; 这不是偷懒， &gt;_&gt;，这是提高工作效(bi)率(ge) 怎么装除了以上比较麻烦的命令行，也可以使用 Homebrew 安装，如下 brew install tree 在某个项目下执行 tree 命令即可 # tree -L 1 指只显示一级目录 . ├── README.md ├── index.html ├── index.js ├── node_modules └── package.json tree 命令后面的参数有其他可选，具体我们可以用 tree –help 来查看 usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;] [--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;] ------- Listing options ------- -a All files are listed. -d List directories only. -l Follow symbolic links like directories. -f Print the full path prefix for each file. -x Stay on current filesystem only. -L level Descend only level directories deep. -R Rerun tree when max dir level reached. -P pattern List only those files that match the pattern given. -I pattern Do not list files that match the given pattern. --ignore-case Ignore case when pattern matching. --matchdirs Include directory names in -P pattern matching. --noreport Turn off file/directory count at end of tree listing. --charset X Use charset X for terminal/HTML and indentation line output. --filelimit # Do not descend dirs with more than # files in them. --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;. -o filename Output to file instead of stdout. -------- File options --------- -q Print non-printable characters as &#39;?&#39;. -N Print non-printable characters as is. -Q Quote filenames with double quotes. -p Print the protections for each file. -u Displays file owner or UID number. -g Displays file group owner or GID number. -s Print the size in bytes of each file. -h Print the size in a more human readable way. --si Like -h, but use in SI units (powers of 1000). -D Print the date of last modification or (-c) status change. -F Appends &#39;/&#39;, &#39;=&#39;, &#39;*&#39;, &#39;@&#39;, &#39;|&#39; or &#39;&gt;&#39; as per ls -F. --inodes Print inode number of each file. --device Print device ID number to which each file belongs. ------- Sorting options ------- -v Sort files alphanumerically by version. -t Sort files by last modification time. -c Sort files by last status change time. -U Leave files unsorted. -r Reverse the order of the sort. --dirsfirst List directories before files (-U disables). --sort X Select sort: name,version,size,mtime,ctime. ------- Graphics options ------ -i Don&#39;t print indentation lines. -A Print ANSI lines graphic indentation lines. -S Print with CP437 (console) graphics indentation lines. -n Turn colorization off always (-C overrides). -C Turn colorization on always. ------- XML/HTML/JSON options ------- -X Prints out an XML representation of the tree. -J Prints out an JSON representation of the tree. -H baseHREF Prints out HTML format with baseHREF as top directory. -T string Replace the default HTML title and H1 header with string. --nolinks Turn off hyperlinks in HTML output. ---- Miscellaneous options ---- --version Print version and exit. --help Print usage and this help message and exit. -- Options processing terminator. 部分常用命令 tree -a 显示所有 tree -d 只显示文件夹 tree -L n 显示项目的层级，n表示层级数，比如想要显示项目三层结构，可以用tree -l 3； tree -I pattern 用于过滤不想要显示的文件或者文件夹。比如你想要过滤项目中的 node_modules 文件夹，可以使用 tree -I “node_modules”； tree &gt; tree.md 将项目结构输出到 tree.md 这个文件]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew]]></title>
    <url>%2F2018%2F12%2F12%2FHomebrew%2F</url>
    <content type="text"><![CDATA[什么是 Homebrew ？ 如图上所示，The missing package manager for macOS，macOS不可缺少的包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能，简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 安装用官网给出的命令即可 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 显示如下界面 中间的 Password 是让你输入权限密码，安装过程中很慢是因为 macOS 的 Terminal 默认不走代理，所以需要手动设置让 Terminal 走代理，最新版的 Shadowsocks 已经支持复制终端代理命令。 直到看见 Installation successful，证明安装成功了， Homebrew 安装成功后，会自动创建目录 /usr/local/Cellar 来存放 Homebrew 安装的程序， 这时你在命令行状态下面就可以使用 brew 命令了 常用命令安装 brew install packageName example: brew install mongodb 搜索 brew search packageName example: brew search mongodb 卸载 brew uninstall packageName example: brew uninstall mongodb 更新所有 brew update 更新指定包 brew update packageName example: brew update mongodb 已安装 brew list 查看包信息 brew info packageName example: brew info mongodb 查看版本 brew -v 卸载/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; 其他更多信息请移步 官网]]></content>
      <categories>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>“Homebrew”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Development cannot be enabled while your drive is locked]]></title>
    <url>%2F2018%2F11%2F28%2FDevelopment-cannot-be-enabled-while-your-drive-is-locked%2F</url>
    <content type="text"><![CDATA[最近接触 ios，真机测试时遇到的一些问题总结下 问题重现选择真机运行时，提示如下： “Develpment cannot be enabled while your device is locked. Please unlock your device and reattach.(0xE80000E2)” 解决办法应该是连接设备的时候没有信任此电脑，手机连上电脑，Settings(设置) - General(通用) - Reset(重置) -&gt; Reset Localtion Privacy(重置和隐私) ，手机会提示是否信任此电脑，选择是 具体可以看看 Apple 官方解释 点这里]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 React 的一些使用心得]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%85%B3%E4%BA%8E-React-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS设计模式]]></title>
    <url>%2F2018%2F08%2F08%2FCSS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计模式？ 提到设计模式，有人会说，这不就是你们工程狮经常装x的词汇么，但我觉得，这玩意儿只有你懂，用的到的时候才有用，基本上用得上的地方还是少的吧～ 上软工课那会儿，设计模式(design pattern)是对软件设计中普遍存在(反复出现)的各种问题，所提出的解决方案这个术语是由埃里希·伽玛(Erich Gamma)等人在1990年代从建筑设计领域引入到计算机科学，大白话设计模式就是基石脉络，同建筑结构一样。 接下来引入官方解释～，设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别)或对象)来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。 随着软件开发社群对设计模式的兴趣日益增长，已经出版了一些相关的专著，定期召开相应的研讨会，而且沃德·坎宁安（Ward Cunningham）为此发明了WikiWiki用来交流设计模式的经验。 更为详细的解释点这里) 今天谈谈 CSS 设计模式 这个词汇很常见，几乎所有阵营的编程语言都会有几套，但都没有深入研究，原因如下： 有问题修改或者按团队规范就行了，那么钻牛角尖干嘛 我就是不用能咋滴啊～。 说白了就是用不到～～啊，现在写的一些样式代码量还达不到需要规划组织的程度，常写的布局，动画，还得兼顾兼容，哪来的时间去想去这些方法论的问题。 这都是我经历过的，你们肯定也是～ 但随着时间的推移，个人技术的成长，肯定会接触到更大更多更复杂的项目，这时候就需要自上而下，全流程的去思考一些问题，比如：风格的制定、色调、模块、布局方式、交互方式、逻辑等等，如果再加上团队合作，若再没有一个规划的话，要不了多久，那些看起来没问题的代码，就会暴露出各种问题，模块命名、类的命名、文件的组织、共用模块的提取、代码的复用、可读性、扩展性、维护性，现今项目通常都相当复杂 既然对 CSS 进行设计，那么证明本身还是存在一些问题的，最明显的就是，它任何一个规则都是全局性的声明，会对引入它当前页面中所有相关元素起作用，不管这个效果是不是你要的，这个时候你需要的是一个独立且可整合可维护的模块。 从需求层面布局刚开始上学写记叙文的时候并不会考虑六要素，通常都是下笔即写，因为我们意识不到，写代码也一样，一开始我们只是去定义规则，属性，语法正确，页面做出来了就ok，但慢慢发现，页面是有“骨架”的，按照骨架去组织代码不是美哉？比如header，navigation，slider，banner，content，footer。 但一些组件的复用性还是很高的，又不能单独算一个模块，比如 Breadcrumb Trail，Pagination，Modal。 这些需要单独拆分css还有与之对应的js，应该算早期的组件化思路。 拆分通过上面的布局分析，现在组织清晰了很多，维护性明显高了很多，但仔细研究，这还不够，还有一些细微的功能复用性也很高，比如 border，background，icon，font，layout，这些如果在需要用的地方都定义一次，代码仓库就爆炸了，维护就很困难了，所以需要拆分开。 排序经过了布局和拆分，代码结构已经很清晰了，内容，功能模块架子已经搭好，分类清晰后还需要排序，比如你会看到如下： @import “common._eset.css”; @import “icon_sprite.css”; @import “common_btns.css”; @import “common_header.css”; @import “common_tab.css”; @import “common_footer.css”; 看，现在是不是清晰了很多，而且很容易维护，同时有利于继承或层叠。 此外还可进行代码范围比如： 文件头部建立一个简要目录 利用区块注释(详细写明改代码的目的，状态切换，调整原因，交互逻辑，利己又利人) 从结构层面层级嵌套我同事写过十级嵌套 CSS，墙都不扶，就扶他！只要对浏览器的渲染原理有点了解的都知道，在解析 CSS 规则的时候，是从右向左，一层层的去遍历寻找，如果层级太多，必然增加了渲染时间，影响渲染速度，另外，如果选择器层级过多，也就间接反应了，你的HTML结构可能写得不够简洁，其实从我们日常需求来看，4层以内足可以解决绝大多数问题。 避免使用元素选择器在 HTML 中，有很多常用的高频元素，比如，div、p、span、a、ul等，如果你在多层选择器的最内层使用了元素选择器，那么在开始寻找时，浏览器就会遍历HTML中的所有该元素，这是没有必要的，在具体的代码模块中，尽量不要使用元素选择器，否则会出现一些不可预料的问题。 文件引入的数量和顺序看起来似乎影响不到什么，无非就是多请求几次 ，样式是否加载，如果出于对用户体验的极致追求，还是希望请求减少文件加载先后，以防在难以缩减文件大小的时候能正常并正确展示用户先看到的。 从现有模式层面OOCSSOOCSS 并不是什么新技术，只是一种撰写 CSS 的设计模式，重点两个： 减少对 HTML 结构的依赖 增加 CSS 它的两个 O 分别是 O =&gt; Object O =&gt; Oriented 它的两大原则 结构(Structure)与样式(Skin)分离 容器(Container)与内容(Content)分离 全写一起是这样 #box{ width: 500px; border: solid 1px #000; background: #aaf; box-shadow: rgba(0, 0, 0, 0.5) 5px 5px 5px; } #button{ width: 100px; height: 50px; padding: 10px; border: solid 1px #000; box-shadow: rgba(0, 0, 0, .5) 5px 5px 5px; } 结构样式分离 .box{ width: 500px; } .button{ width: 100px; height: 50px; padding: 10px; } .skin{ border: solid 1px #000; bacdground: #aaf; box-shadow: rgba(0, 0, 0, 0.5) 5px 5px 5px; } 容器与内容分离 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-img&quot;&gt; &lt;img src=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box-content&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 这样既可以增加 CSS 的复用性，相同组件只需套用一个 CSS 即可。 Bootstarp 其实就是个很棒的 OOCSS 例子，但过度使用也会让 HTML 长度和阅读还有管理难度增加 SMACSS 1、Base浏览器的 reset 可以写在这里,这里只会对标签元素本身做设定，不会出现任何 class 或 id，但是可以有属性选择器或是伪类： html {} input[type=text] {} a:hover {} 2、LayoutLayout 是指整个网站的「大架构」的外观，而非 .button 这种小元件的 class，网站通常会有一些主要的大区块，可能是 header 或 footer，Layout 就是用来定义这些「大架构」的 CSS。 #header { margin: 30px 0; } #articles-wrapper { ......; } .sidebar { &amp;.sidebar--right { ......; } &amp;.sidebar-left { ......; } } 3、Module模块样式，就是我们在对页面进行拆的过程中，所抽取分类的模块，这类的样式分别写到一起. 4、StateState 负责定义元素不同的状态下，所呈现的样式 &lt;nav class=&quot;nav--main&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;.........&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a&gt;.........&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;.........&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 5、ThemeTheme 是画面上所有「主视觉」的定义 从实际层面虽然已有成熟的设计模式，但是跟自己的项目可能不搭，这时就需要去实践，最好的模式就是在项目进行中，不断的磨合调整而出 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无时间日]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%97%A0%E6%97%B6%E9%97%B4%E6%97%A5%2F</url>
    <content type="text"><![CDATA[今天是全年最特殊的一天 —— 无时间日 什么是”无时间日”呢？答案是 , 它是玛雅历的最后一天 , 而这一天不属于任何一天 , 没有任何的时间坐标 , 只存在于当下. 公历 7月24日 就是旧的一年的最后一天 , 很特别的是 7月25日 是玛雅历的”无时间日” , 就是让我们在新与旧的年度之间 , 有个完整的一天 , 可以完全释放旧的生活与思维 , 重新制定新一年的方向与计划 , 全然体验什么事”时间的力量” , 提醒我们”活在纯粹当下的自由”. 这一天是一直都没有办法理解什么是无时间日 , 感受最深的就是无时间日的一个状态. 有的人出门总是要计划好时间 , 不然你的这一天就不太好安排 , 或许会错过你最想要看的表演 , 或许你会错过你觉得你想要去参加什么节目或者活动的一切 , 有的人出门就是随着时间而走 , 什么时候醒了什么时候来 , 什么时候走到哪里就到哪里，一切的一切都会让自己变得随心所所欲. 而在这段时间里总是感觉自己不能有很好的时间来休息 , 途中还有一个时间差的问题 , 到目前为止一直都没有把这个状态调节回来. 每天醒来都不会想着去看时间 , 每一时间都是看看有没有出太阳 , 而起床后洗漱完就是去吃早点，早点结束开始各”地”奔波开始玩耍 , 哪里有节目就会去哪里，哪里热闹就往哪里凑 , 一天到晚或许你连天空都看不到 , 你不会知道此时是什么时间 , 此时外面的天气是如何的 , 风是如何的 , 跟着心走 , 哪里好玩去哪里 , 哪里有好看的表演人肯定停顿在哪里 , 那个时候大家都会想要说去看时间这个东西. 玩累了 , 那差不多是该休息了 , 玩到停顿差不多就到吃饭时间 , 吃完大家补充能量后接着来 , 永远都是能量充足的 , 而我呢却每天都感觉懒洋洋的 , 一直都认为自己不适合那种地方 , 可是不管在哪里，我总是能让自己感受到很多很多的东西 , 带着头脑与带着心完全就是两种感受 , 如果是我换个角度我不一定能做得很好 , 如果是我换个做法不一定就能像他们一样的尽心尽责的做着自己的工作 , 有时候看着他们会很羡慕 , 毕竟每天玩耍就是他们的工作 , 而我们总是得面对很多不愿意面对的人事物 , 可是当麻木了 , 你对这一切没有激情了，那时间、人、事、物对于你来说什么都不重要了吧 , 更不用说你需要去做其他的什么事情. 无时间日很好过 , 同时也觉得特不舒服 , 因为我们总是看着表 , 到点吃饭 , 到点做事 , 可这样的无时间日会让你不急不燥不慌不忙，把所有的身心都放松下来 , 只顾着当下的一切 , 其他的一切都抛之脑后 , 什么烦恼都抛开 , 这便是最棒的一种感受 , 把所有的美好 , 所有的放松都通过深深的深呼吸把它们都吸入细胞里 , 深深的记住。当你很累的时候 , 随时调动细胞的记忆把它释放出来，感觉着当时的感受来缓解身心的疲惫. 如果你也觉得自己不知道要如何 , 请你也感受感受无时间日的状态 , 把所有的一切都关闭 , 带着自己 , 带着觉知 , 带着心去就成 , 其他的通通都丢了. 相信无时间日会给你带来不一样的感受与新的瞬间决断力. 当你过好了今天 , 你就能过好未来的 365 天 , 因为今天就是一切当下汇聚的日子 , 而我们的生命是由所有的当下所构成的 , 当我们过好了每一个当下 , 就意味着我们将会过好我们一切的过去现在与未来 , 还记得吗?未来不存在 , 当下即未来. 而我们 , 每时每刻都是时间的旅行者 , 每时每刻都在穿越亿万世界线汇聚在此刻的焦点 , 以”此刻”为支点编织绘制出过去和未来的样子. 回过头来 , 真正地睁开双眼 , 去看——我们现在就站在这个支点之上.你现在 , 此刻就站在这个魔法汇聚的支点之上. ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 动画]]></title>
    <url>%2F2018%2F07%2F12%2FCSS3-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[最近笔试遇到两个 c3 动画题 , 记录一下 桌球运动轨迹球 A 和球 B , 静止时相隔 100px , 触发后球 A 撞向球 B , 球 B 顺势滚动并撞到屏幕后弹至原位 , 可参考桌球的运动轨迹. 分析: 题目没有说是水平/垂直方向运动 , 我就以水平方向运动吧. A —–100px—– B , 假设球 A 和球 B自身宽各 30 px , 总宽 200 px , 那么球 A 的运动值为 100 px , 球 B 的运动值为 200 - (30 * 2 + 100) = 40 px. HTML 部分 &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;ball1&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;ball2&quot;&gt;B&lt;/div&gt; &lt;/div&gt; CSS 部分 body{ margin: 200px 200px; padding: 0; } #box{ width: 200px; height: 200px; border: 1px solid cornflowerblue; } .ball1,.ball2{ width: 30px; height: 30px; border-radius: 50%; background-color: limegreen; float: left; line-height: 30px; text-align: center; } .ball2{ margin-left: 100px; } .ball1{ animation: go 2s; } .ball2{ animation: goAgain 4s; } @keyframes go { 0%{ transform: translateX(0); } 50%,51%{ -webkit-animation: ease-in both; transform: translateX(100px); } } @keyframes goAgain { 0%,25%{ transform: translateX(0); } 50%,60%{ -webkit-animation: ease-in both; transform: translateX(40px); } } 主要就是两个球的过渡时间 , 其它兼容的什么没写 效果如下: 摩天轮旋转动画分析: 大致三个功能 , 一 , 球体旋转 , 二 , 座位固定位置 , 三 , 座位底部始终垂直于水平线 球体旋转很简单 , rotate(360deg) , 座位固定 position 定位 , 底部始终垂直于水平线 , 每个座位单独设置一个 animation 属性 , 逆时针 360° 旋转 HTML 部分 &lt;div id=&quot;sky-wheel&quot;&gt; &lt;img src=&quot;img/background.png&quot;&gt; &lt;img src=&quot;img/person1.png&quot;&gt; &lt;img src=&quot;img/person2.png&quot;&gt; &lt;img src=&quot;img/person3.png&quot;&gt; &lt;/div&gt; CSS 部分 #sky-wheel{ margin: 100px auto; width: 800px; position: relative; animation: rotate 10s infinite linear; } @keyframes rotate { // 主球旋转 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } // 结构性伪类选择器单独定位每个座位 img:nth-child(2) { position: absolute; top: 80px; left: 400px; animation: seat 10s infinite linear; transform-origin: top center; // 旋转基点 } img:nth-child(3) { position: absolute; top: 700px; left: 400px; animation: seat 10s infinite linear; transform-origin: top center; } img:nth-child(4) { position: absolute; top: 300px; left: 0px; animation: seat 10s infinite linear; transform-origin: top center; } @keyframes seat { 0% { transform: rotate(0deg); } 100% { transform: rotate(-360deg); // 实现座位底部始终垂直于水平线 } } 同样的 , 兼容属性没写 效果如下: 素材来自网络 , 有时间用纯 HTML + CSS 画一个 其他还有一个很有意思的 JS 题 if(!&quot;a&quot; in window) { var a = 1; } alert(a); // undefined 为什么会是 undefined 呢 ? 首先所有的全局变量都是 window 的属性 , var a = 1 等价于 window.a = 1; 变量声明被提前了 , 但变量赋值没有 , 这段代码可以改写为: var a; if (!(&quot;a&quot; in window)) { a = 1; } alert(a); 先声明 a , 然后判断 a 是否在存在 , 如果不存在就赋值为 1 , 但 a 永远在 window 里 , if 语句永远不会执行 , 所以是 undefined . ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 数组遍历]]></title>
    <url>%2F2018%2F07%2F06%2FJS-%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[JS数组遍历的几种方式 JS 数组遍历 , 基本就是 for、forin、foreach、forof、map 等等一些方法 普通 for 循环for(i = 0; i &lt; arr.length; j++) { }; 最简单的一种 , 使用频率相当高 , 虽然性能不弱 , 但仍有优化空间 强版 for 循环for(i = 0,len = arr.length; i &lt; len; i++) { }; 使用临时变量 , 将长度存储 , 防止重复获取长度 , 只有数组较大的时候才会比普通 for 循环效果明显 弱版 for 循环for(i = 0; arr[i] != null; j++) { }; 这种方法好像不是很常见 , 其实我压根就没见人用过 , 不过严格意义说这也算 for 循环 , 只不过不是判断 length , 而是判断变量本身 看起来好像比普通 for 循环的性能要小 for…each 循环arr.forEach(function(e){ }); 数组自带方法 , 使用频率也很高 , 但性能还不如普通 for 循环 for…each 循环 2.0 版Array.prototype.forEach.call(arr,function(el){ }); for…each 是 Array 自带的方法 , 实际性能要比普通 for…each 弱 for…in 循环for(i in arr) { }; 感觉用这个的最多 , 但其实 , 这个是效率最低的 map 遍历arr.map(function(n){ }); 感觉这个很优雅 , 但它的性能还不如 for…each for…of 遍历(ES6 新增)for(let value of arr) { }); 这种方式是 ES6 里面的 , 性能要好于 for…in , 但仍然比不上普通 for 循环 各种遍历方式的性能对比普通 for 循环才是最优雅的 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo + github 配置个人博客]]></title>
    <url>%2F2018%2F06%2F26%2Fhexo-github-%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo + github 搭建博客 注册 githubhttps://github.com/join?source=header-home 用户名 - 邮箱 - 密码 , 下一步 新建仓库 点击 new repository 新建仓库 新建项目 GitHub Pagessetting 页面设置 gh-pages (一般都是默认开启) 地址栏输入上面的地址 , 不出意外的话大功告成了 配置 githttps://github.com/git-for-windows/git/releases/download/v2.17.0.windows.1/Git-2.17.0-64-bit.exe 安装成功后 , 桌面空白处右键 , 不出意外能看到新增两个 git 命令 安装完成 , 还需要进一步配置 , 点击 Git Bash Here git config –global user.name “Your Name” / 用户名 / git config –global user.email “email@example.com“ / 邮箱 / / git config命令的–global参数 , 用了这个参数 , 表示你这台机器上所有的Git仓库都会使用这个配置 , 当然也可以对某个仓库指定不同的用户名和Email地址 / 配置 Node 参考 Node 配置 配置 Hexo安装 hexonpm install hexo-cli -g 如果 npm 安装进度很慢 , 证明你被 GFW 看上了 , 推荐使用淘宝镜像 初始化 blog 你可以在硬盘任何一个分区 , 只要你喜欢 , 新建一个文件夹来管理你的 blog , 然后在这个文件夹内 , 右键打开 git base here , 就是这么神奇 , 哪里都有它 检测 hexo 是否安装成功 hexo -v (-v 不行则换成 -version) 初始化 hexo hexo init npm install 或 cnpm install (淘宝镜像) 打开 hexo hexo g hexo s // 提示信息 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 证明 ok 了 浏览器地址栏输入 http://localhost:4000 , 你将会看到以下 blog 搭建完成 对接 github 如果换了环境呢(公司或家里) 新建一个 hexo 分支(branches) 这个分支就是用来放置 hexo 的核心源文件的！ bolg 文件内右键打开 git base here , 如果你的文件正确的话 , 现在是没有 .git 文件 , 这是个隐藏文件夹 , 有的小伙伴没有设置怎么查看隐藏文件 , 不会的可以根据你的系统去 google 一下(拒绝面向百度编程) git init // 初始化本地仓库 , 会生成一个 .git 文件 git add source scaffolds themes .gitignore _config.yml package.json // 将这 6 个文件提交到 hexo 分支 , 这就是源文件了 , source 里面就是装的你的博客文章 git commit -m “Blog Source Hexo” git branch hexo // 新建 hexo 分支 git checkout hexo // 切换到 hexo 分支上 git remote add origin https://github.com/xxx/xxx.github.io.git(换成你自己的 , 如下图) // 将本地与 Github 项目对接 , 很多教程说要用 ssh , 我这里用 https 也没有出错 git push origin hexo // push 到 Github 项目的 hexo 分支上 提交完成之后 , 你可以在 github 上的厂库里看到 将博客文章提交到 master 页面 在你博客文件夹中找到 _config.yml 文件 , 修改以下几处 (文末附上其他配置信息介绍) # Site title: # 博客名 subtitle: # 副标题 description: # 描述 author: # 作者 language: zh-Hans # 语言 deploy: type: git repository: https://github.com/xxx/xxx.github.io.git (换成你自己的) branch: master 然后执行以下命令 hexo g hexo d 现在可以再打开 yourname.github.io 看看 , 不出意外成功了 换了电脑之后怎么弄 首先保证新电脑上 git / node.js / github 都要有 git clone -b hexo https://github.com/xxx/xxx.github.io.git // 将 Github 中hexo 分支 clone 到本地 cd yourname.github.io //切换到刚刚 clone 的文件夹内 npm install // 注意 , 这里一定要切换到刚刚 clone 的文件夹内执行 , 安装必要的所需组件 , 不用再 init npm install -g hexo-cli // 如果电脑上没有安装这个 , 需要先安装 hexo new post “new blog name” // 新建一个 .md 文件 , 并编辑完成自己的博客内容 git add source //经测试每次只要更新 sorcerer 中的文件到 Github 中即可 , 因为只是新建了一篇新博客 git commit -m “XX” git push origin hexo // 更新分支 hexo d -g // push 更新完分支之后将自己写的博客对接到自己搭的博客网站上 , 同时同步了 Github 中的 master 如果 hexo d -g 没有生效 执行以下命令 hexo g hexo d 如果有多个电脑在用 , 每次写了 blog 在其他电脑上执行 git pull origin hexo 完整配置信息# Site #站点信息 title: blog Name #标题 subtitle: Subtitle #副标题 description: my blog desc #描述 author: me #作者 language: zh-CN #语言 timezone: Asia/Shanghai #时区 # URL url: http://yoururl.com #用于绑定域名, 其他的不需要配置 root: / # permalink: :year/:month/:day/:title/ permalink: posts/title.html permalink_defaults: # Directory #目录 source_dir: source #源文件 public_dir: public #生成的网页文件 tag_dir: tags #标签 archive_dir: archives #归档 category_dir: categories #分类 code_dir: downloads/code i18n_dir: :lang #国际化 skip_render: # Writing #写作 new_post_name: :title.md #新文章标题 default_layout: post #默认模板(post page photo draft) titlecase: false #标题转换成大写 external_link: true #新标签页里打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: #语法高亮 enable: true line_number: true #显示行号 auto_detect: true tab_replace: # Category &amp; Tag #分类和标签 default_category: uncategorized #默认分类 category_map: tag_map: # Date / Time format #日期时间格式 ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination #分页 per_page: 10 #每页文章数, 设置成 0 禁用分页 pagination_dir: page # Extensions #插件和主题 ## 插件: http://hexo.io/plugins/ ## 主题: http://hexo.io/themes/ theme: next # Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面 deploy: - type: git repo: git@gitcafe.com:username/username.git,gitcafe-pages - type: git repo: git@github.com:username/username.github.io.git,master # Disqus #Disqus评论系统 disqus_shortname: plugins: #插件，例如生成 RSS 和站点地图的 - hexo-generator-feed - hexo-generator-sitemap 常用命令 hexo new &quot;我的第一篇博客&quot; // 创建 .md 文档格式的博客 hexo new page home // 创建分类 hexo g // 更新至本地服务器 hexo d // 更新至 github hexo s // 运行 hexo Tips 创建分类例如 tags , 如你新建的文档是要归属于 tags 类名 之下 , 则在 md 文件表示为 tags: “vue” // 类别 categories: vue ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地 vue 项目上传至 GitHub]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%9C%AC%E5%9C%B0-vue-%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3-GitHub%2F</url>
    <content type="text"><![CDATA[前言 最近初步完成了 vue仿某商城 , 上传至 github , 并实现一个简单的预览功能 , 遇到一些问题 , 分享一下解决的过程 打包 Vue 项目Vue 项目完成时 , 执行以下命令 npm run build 实际上此命令就是执行 build.js 文件 , 将项目打包成静态资源 , 项目根目录下会多出一个 dist 文件夹 static 文件下包括项目打包后的 css、js、img、fonts (字体图标) 项目资源无法加载但打开 dist 下 index.html 文件 , 页面却显示空白 , F12 打开控制台查看 发现并没加载任何 css、js 文件 , 解决办法如下： 打开根目录 config 下的 index.js , 找到如下代码： 将 assetsPublicPath: &#39;/&#39; , 改为 assetsPublicPath: &#39;./&#39; 或 assetsPublicPath: &#39;&#39; 保存 , 运行 npm run build , 在新生成的 dist 下打开 index.html , 页面结构正常显示 , 但是页面字体图标和 mock 的数据无法正常加载 字体图标无法加载页面中用 background 加载的图片可以正常显示 , 但是所有的字体图标都不能正常显示 , 解决办法如下： 打开根目录 build 下的 utils.js , 找到如下代码： fallback: &#39;vue-style-loader&#39; 下添加 publicPath: &#39;../../&#39; 保存 , 运行 npm run build , 在新生成的 dist 下打开 index.html , 页面字体图标正常显示 Mock 数据无法正常加载项目的绝大部分页面内容是通过在跟目录下创建的 data.json 文件渲染到页面上的 , 是模拟从后端请求数据的 , 开发调试时用 npm run dev 命令 , 会借助node启动一个本地服务器 , 可以正常的渲染出相应的数据。而通过打包后的项目时属于静态资源的 , 点击 index.html , 是无法加载 mock 的数据的 , 浏览器也会报跨域的错误。若想正常的加载 mock 数据 , 最好的方式是讲打包后的资源丢到服务器中 , 或者使用 jsonp 请求线上真实数据，因为它的原理是利用 script 标签来获得数据 , 在github 上是可以预览的 使用 git 命令将项目上传至 github项目文件夹内打开 Git Bash Here , 输入 git init 把文件添加到版本库中 , 不要忘记后面的小数点”.” , 添加文件夹下的所有文件 git add . 把文件提交到仓库 , 引号内为提交说明 git commit &quot; update message&quot; 关联远程库​ git remote add origin 仓库地址 (例如:https://github.com/LixingY/smartisanpay.git) 将项目所有 push 文件到仓库中​ git push -u origin master 后期执行 git push 即可 github 在线预览github 预览是需要利用 GitHub Pages , 点击项目仓库 Settings , 找到 GitHub Pages , 切换到 master branch 地址生成了 , 如无法预览 , 地址后面加上 /dist 即可 心得github 作为星球上最流行的开源托管服务的分布式网站 , 作为程序员 , 掌握基本 github 使用方法 , 无论是对于分享、托管自己的项目 , 还是查阅其它优秀的开源项目 , 都是十分有帮助的 Tips: git 常用命令git init 配置git git add . 更新所有文件 git commit 提交文件至仓库 git status 查看状态 git diff 查看改动说明 git remote 查看远端服务器别名 , 加上 -v 显示 url 信息 git remote add server_url local-alias 添加远端服务器 git clone project_url local_alias 拷贝项目到本机中 git push server_url/local-alias 更新远端服务器仓库 git pull server_url/local-alias 更新本地服务器仓库 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述 var/let/const 三者区别]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%AE%80%E8%BF%B0-var-let-const-%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[var 先来看看 MDN 的定义 The variable statement declares a variable, optionally initializing it to a value. 声明变量并初始化 , 作用域是函数体的全部 { var a = 1; let b = 2; } console.log(a); // a is not defined console.log(b); // 2 var： 变量提升(无论声明在何处 , 都会被提至其所在作用于的顶部)let： let绑定不受变量提升的约束 , 这意味着let声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前 , 引用它将会导致 ReferenceError (而使用 var 声明变量则恰恰相反，该变量的值是 undefined) , 该变量处于从块开始到初始化处理的“暂存死区” function fn(){ console.log(x); // undefined console.log(y); // undefined var x = 1; var y = 2; } fn(); 执行 fn 过程： 进入 fn 并创建环境 找到 fn 中所有用 var 声明的变量 , 在这个环境中「创建」这些变量 将这些变量「初始化」为 undefined 开始执行代码 分别将 x / y 赋值为 1 / 2 也就是说 var 声明会在代码执行之前就将「创建变量 , 并将其初始化为 undefined」 let 先来看看 MDN 的定义 The let statement declares a block scope local variable, optionally initializing it to a value. 声明块级作用域变量 , 作用域只是外层块 , 而不是整个外层函数 { console.log(x); // Uncaught ReferenceError: x is not defined let x = 1 x = 2; } 执行 {} 里过程： 找到所有用 let 声明的变量 , 在环境中「创建」这些变量 开始执行代码(注意并没初始化) 执行 x = 1 , 将 x 「初始化」为 1 执行 x = 2 , 对 x 进行「赋值」 let x = &#39;global&#39;; { console.log(x); // Uncaught ReferenceError: x is not defined let x = 1; } 两个原因： console.log(x) 中的 x 指的是下面的 x , 而不是全局的 x 执行 log 时 x 还没「初始化」 , 所以不能使用(也就是所谓的暂时死区) const 先来看看 MDN 的定义 Constants are block-scoped, much like variables defined using the let statement. The value of a constant cannot change through re-assignment, and it can’t be redeclared const 是块级作用域 , 类似于 let , 但不同之处在于 const 不能通过重新赋值来改变 , 也不能重新声明 仅从字面上理解也是不够的 , 它所不能修改的是栈内存在的值和地址 什么是栈内存在的值和地址呢？ 基本类型 Boolen , Number, String 是把直接值直接存在栈内 引用类型 Object (Function, Array ….) 是把值存在对应的地址中 const a = new String(&#39;123&#39;) ; a = &#39;456&#39;; console.log(a); // TypeError: Assignment to constant variable. const 和 let 其实就一个区别 , const 只有「创建」和「初始化」 , 没有「赋值」过程 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下一代 Node 强势来袭: Deno]]></title>
    <url>%2F2018%2F06%2F04%2F%E4%B8%8B%E4%B8%80%E4%BB%A3-Node-%E5%BC%BA%E5%8A%BF%E6%9D%A5%E8%A2%AD-Deno%2F</url>
    <content type="text"><![CDATA[摘要 Node 之父 Ryan Dahl 发布新的开源项目 deno , 从官方介绍来看 , 可以认为它是下一代 Node , 使用 Go 语言代替 C++ 重新编写跨平台底层内核驱动 , 上层仍然使用 V8 引擎 , 最终提供一个安全的 TypeScript 运行时 特性 支持 TypeScript 2.8 开箱即用 无 package.json , 无 npm，不追求兼容 Node 通过 URL 方式引入依赖而非通过本地模块 , 并在第一次运行的时候进行加载和缓存 , 并仅在代码使用 –reload 运行 , 依赖才会更新 , 引入方式见文章尾部 可以控制文件系统和网络访问权限以运行沙盒代码 , 默认访问只读文件系统可访问 , 无网络权限 , V8 和 Golang 之间的访问只能通过 protobuf 中定义的序列化消息完成 发生未捕捉错误时自动终止运行 支持 top-level 的 await 最终创建单一可执行文件 目标是兼容浏览器 可以作为库引入 , 用于建立自己的 JavaScript runtime 总结这几个特性 , 有好几个都是针对目前 Node 的痛点而来的 , 包括无 package.json、依赖的引入和更新方式 , 针对的就是被广泛吐槽的过大的 node_modules , 同时 , 不追求兼容 node , 可以视为 ry 想彻底抛弃 node 包袱 , 打造一个更好的 JS 运行时 Deno 和 Node 的区别是什么？ry 开玩笑称 , 目前两者最大的区别是 Node 大行其道 , 而 Deno 尚未投入使用 , 从更高层面上来说 , Deno 尽可能简化 V8 与系统 API 的耦合 , 并打造更加简单、稳定的模块系统 , 以及一个安全的沙箱运行环境 , 再者 , 使用 Golang 而不是 C++ 作为底层语言 , 这样 , 添加高级功能时会比在 Node 中更加容易 , 比如在 Go 中添加 http2.0支持 , 只需添加一些路由 API 和一些配置到 protobuf 中 , Deno 诞生的目的 , 是为了创建更简单和安全的非浏览器 runtime , 它在这个时候出现 , 是因为现在的开发工具比 2009 年更好 , 我们还可以认为 Deno 将是目前 Node 生态一些难解问题的终极答案 , 比如依赖管理、安全性、稳定性、横向扩展等等 , Deno 的诞生 , 将启发更多人投入到下一代 Node 的探索当中 , 这比之前 Node 的一些分叉更具备创新和革命性. Deno Github 地址引入方式 import { log } from &quot;./util.ts&quot; import { test } from &quot;https://unpkg.com/deno_testing@0.0.5/testing.ts&quot; ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝与深拷贝]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[什么是浅拷贝 / 深拷贝 ?浅拷贝对于字符串类型 , 浅拷贝就是对值的复制 , 对于对象来说 , 浅拷贝是对对象地址的拷贝 , 并没有开辟的新的栈 , 也就是复制的结果是两个对象指向同一个地址 , 修改其中一个对象的属性 , 则另一个对象的属性也会改变. /* 浅拷贝 */ var obj1 = { name: &#39;tom&#39;, receiveInfo: { // 父对象中 receiveInfo 属性是另外两个对象 , 而不是简单数据类型 home: &#39;home1&#39;, school: &#39;school1&#39; } }; var obj2 = {}; function shallowCopy(obj1, obj2) { for (var key in obj1) { if (obj1.hasOwnProperty(key)) { obj2[key] = obj1[key]; } } }; shallowCopy(obj1, obj2); obj2.receiveInfo.home = &#39;home2&#39;; console.log(obj2.receiveInfo.home); // home2 console.log(obj1.receiveInfo.home); // home2 父对象 obj 的属性没有定义为基本数据类型(基本数据类型的定义都会开辟新的内存) , 而是指向了另外两个对象属性 , 这时子类从父类里拷贝的 receiveInfo 属性是 receiveInfo 的内存地址 , 也就是说子类和父类指向同一内存地址 , 改变了子类父类也就跟着改变. 深拷贝所谓深拷贝 , 就是能实现真正意义上数组和对象的拷贝 , 可以通过递归的方式实现 , 从而解决上述栗子中的问题. /* 深拷贝 */ var obj1 = { name: &#39;tom&#39;, receiveInfo: { home: &#39;home1&#39;, school: &#39;school1&#39; } }; function deepCopy(obj) { var objArray = Array.isArray(obj) ? [] : {}; // 对象数组区别处理 if (obj &amp;&amp; typeof obj === &quot;object&quot;) { // 判断是否为基本数据类型 for (var key in obj) { if (obj.hasOwnProperty(key)) { if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) { objArray[key] = deepCopy(obj[key]); // 如果是对象 , 则拷贝 } else { objArray[key] = obj[key]; // 否则直接赋值 } } } } return objArray; } var obj2 = deepCopy(obj1); obj2.receiveInfo.home = &#39;home2&#39;; console.log(obj1.receiveInfo.home); // home1 console.log(obj2.receiveInfo.home); // home2 现在可以看到 , 子类拷贝父类而不改变父类 , 实现了所谓继承. 其它方法jQuery 提供了 extend 方法 jQuery.extend([deep], target, object1, [objectN]) var obj = { _name: &#39;Tom&#39;, _receiveInfo: { home: &#39;home1&#39;, school: &#39;school&#39; } } var obj2 = $.extend(true, {}, obj); // 第一个参数设置为true , 则jQuery返回一个深层次的副本 , 递归地复制找到的任何对象 obj2._receiveInfo.home = &#39;home2&#39;; console.log(obj._receiveInfo.home); // home1 console.log(obj2._receiveInfo.home); // home2 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ES6 箭头函数中的 this 绑定问题]]></title>
    <url>%2F2018%2F05%2F29%2F%E5%85%B3%E4%BA%8EES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this%E7%BB%91%E5%AE%9A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于 ES6 箭头函数中的this绑定问题 最近在看高程函数这块 , 得出一个结论 , JS 中是不存在重载的 , 但是可以通过其它方式来模拟 , 并非完美重载 , 这就想到了 arguments 这个数组了 , arguments 是系统中的一个数组 , 用来存储函数传递的参数 , 这和 Java 中写 main 方法时的 (agrs []) 类似 , 在 JS 中 , 可以用这个数组来接受函数传递过来的参数 , 从而根据不同的参数进行判断 , 从而实现不同的效果 , 这就达到了模拟重载的效果 ~~好像过头了 关于 Thisthis 指向问题一直是学习 JS 不可忽视的重要部分 举个栗子var obj = { fn: function () { console.log(this); // {fn: ƒ} } } obj.fn(); 很明显的 this 指向问题 , 谁调用就指向谁 再来个var obj = { fn: function () { setTimeout((function () { console.log(this); // Window })) } } obj.fn(); 这次却指向最外层的 Window,为啥呢？因为这次的this出现在全局函数 setTimeout 的匿名函数里, 并没对某个对象进行显示调用 , 所以指向了 Window 对象. 如果加个箭头 =&gt; 呢 ?var obj = { fn: function () { setTimeout(() =&gt; { console.log(this); // {fn: ƒ} }) } } obj.fn(); 好嘛 , this 又指回宿主了 , 因为箭头函数不会创建自己的 this , 它只会从自己的作用域链的上一层继承 this. 好像看不出啥区别哈 , 加个变量试试var obj = { _num: 1, fn: function () { setTimeout(function () { console.log(this._num); }) } } obj.fn(); // undefined var obj1 = { _num: 1, fn: function () { setTimeout(() =&gt; { console.log(this._num); }) } } obj.fn(); // 1 显而易见 , undefined 和 1 , 没加箭头函数情况下 , 指向 Window.而 Window 里并没有 _num 属性 , 而使用了箭头函数的情况下 , this 指向对象 obj1. 没什么难度 , 来个嵌套版var obj = { _num: 1, fn: function () { var f = () ={ // Object , 指向obj , 输出1 console.log(this); setTimeout(() ={ // Object , 指向obj , 输出1 console.log(this); }); } f(); } } obj.fn(); 如果改动外层指向呢 ?var obj = { _num: 1, fn: function () { var f = function () { console.log(this); // Window , 因为函数 f 定义后并没有对象调用 setTimeout(() =&gt; { console.log(this); // Window , 外层 this 绑定到了 Window , 内层也相当于定义在 Window , 这是个全局环境 }); } f(); } } obj.fn(); 外层都改了 , 内层也改改看var obj = { _num: 1, fn: function () { var f = () ={ console.log(this); // Object , 因为 this 定义在 obj1 对象中 , 所以指向 obj1 setTimeout(function () { console.log(this); // 依旧是 Window , 非箭头函数的情况下还是要看宿主对象是谁 , 如果没有被对象调用 , 函数体中的 this 就绑定 window 上 , 然而内层却不会影响外层 ?? }); } f(); } } obj.fn(); 总结箭头函数的 this 绑定看的是 this 所在的函数定义在哪个对象下 , 绑定到哪个对象则 this 就指向谁 , 如有对象嵌套 , 则 this 绑定到最近的一层对象上. ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3 激活码(持续更新)]]></title>
    <url>%2F2018%2F05%2F29%2FSublime-Text3-%E6%BF%80%E6%B4%BB%E7%A0%81-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Sublime Text3 激活码(持续更新)最近 Sublime 自己更新了 , Version 3.1.1 , Build 3176 , so~ , 之前的激活码就用不了 , 网上找了很多种 , 依然无果 , 不过最后还是找到了 , 虽然不是永久的~~ 方式一将 C:\Windows\System32\drivers\etc 的 hosts 文件中添加一下代码 127.0.0.1 sublimetext.com 127.0.0.1 sublimehq.com 127.0.0.1 45.55.255.55 127.0.0.1 45.55.41.223 方式二复制如下激活码 ZYNGA INC. 50 User License EA7E-811825 927BA117 84C9300F 4A0CCBC4 34A56B44 985E4562 59F2B63B CCCFF92F 0E646B83 0FD6487D 1507AE29 9CC4F9F5 0A6F32E3 0343D868 C18E2CD5 27641A71 25475648 309705B3 E468DDC4 1B766A18 7952D28C E627DDBA 960A2153 69A2D98A C87C0607 45DC6049 8C04EC29 D18DFA40 442C680B 1342224D 44D90641 33A3B9F2 46AADB8F 效果截图 原文链接——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>Sublime Text3</category>
      </categories>
      <tags>
        <tag>Sublime Text3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios 全攻略]]></title>
    <url>%2F2018%2F05%2F26%2Faxiso%20%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[axiosvue 更新到 2.0 之后 , 作者就宣告不再对 vue-resource 更新 , 而是推荐 axios , axios 被越来越多的人所了解 , 看了下 axiso 官方文档 , 点此查看 , 很详细 , 有这个还要什么自行车！ 简介axios 是一个基于 Promise , 用于浏览器和 node 的 HTTP 客户端，它本身具有以下特征： 浏览器端发起 XMLHttpRequests 请求 node 端发起 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持防止 CSRF/XSRF 什么是 CSRF/XSRF ? 安装使用 npm npm i axiso 使用 bower bower instal axios 使用 淘宝镜像 cnpm install axios 使用 cdn &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 引入 import axiox from &#39;axios 接下来就可以使用它跟后端交互了 GETaxios({ url:&#39;/&#39;, // 这里填后端接口地址 method:&#39;get&#39;, // 请求方式 , 默认是get , 可不声明 params:{test:&#39;testData&#39;} // 参数 , 有就填 , 无则省去 }).then( res =&gt; { // 具体操作 console.log(res) }).catch( err =&gt; { // 异常操作 }) POSTaxios({ url:&#39;/&#39;, // 这里填后端接口地址 method:&#39;post&#39;, data:{test:&#39;testData&#39;}, // 参数 , 有就填 , 无则省去 , 需要注意下 , 使用post请求 , 属性要用 data , 本来这样是可以了 , 但后端需要用 json 格式 , 这时还需要加 &quot;transformRequest&quot; 属性 对请求数据进行格式化 transformRequest:function(obj) { var str = []; for ( var p in obj) { str.push(encodeURIComponent(p) + &quot;=&quot; + encodeURIComponent(obj[p])); } return str.join(&quot;&amp;&quot;); } }).then(res =&gt; { // 具体操作 console.log(res) }).catch(err =&gt; { // 异常操作 }) ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修复 windows10 Microsoft Store 丢失问题]]></title>
    <url>%2F2018%2F05%2F24%2F%E4%BF%AE%E5%A4%8Dwindows10-Microsoft-Store-%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[打开 Windows PowerShell(管理员) 或 命令提示符(管理员)输入 Get-AppxPackage *WindowsStore* | Remove-AppxPackage 此时可以看到任务栏和开始屏幕里的应用商店图标均已消失 接着回到命令窗口输入 Get-AppxPackage -AllUsers| Foreach {Add-AppxPackage -DisableDevelopmentMode -Register “$($_.InstallLocation)\AppXManifest.xml”} , 同时并打开防火墙 图中红色标注的信息是因为现在安装的版本没有系统的版本高~ , 并不影响安装 ok , 应用商店图标已经出现 , 问题解决 安装 Microsoft Store 应用打开 windows update 服务两种方法 Windows PowerShell(管理员) 或 命令提示符(管理员) 输入 services.msc Tips：.msc (Microsoft Snap-In Control) 命令是微软管理控制台 MMC (Microsoft Management Console) 用来添加/删除的嵌入式管理单元文件 , 通常通过MMC来管理 , 可以点击开始/运行 , 然后输入下列文件名就可以打开相应的控制窗口,常见的有：diskmgmt.msc (磁盘管理器 , 可以修改盘符 , 格式化和分区) , gpedit.msc (组策略管理器 , 功能强大) , services.msc (各项本地服务管理器) 计算机右键 - 管理 - 服务和应用程序 - 服务 找到 Windows Update - 右键属性 - 启动类型 - 自动 , 同时点击下面的服务状态为启动 , 接着打开防火墙 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F05%2F23%2FGit%2F</url>
    <content type="text"><![CDATA[关于版本控制版本控制是一种记录一个或若干文件内容变化 , 以便将来查阅特定版本修订情况的系统 , 我们对保存着软件源代码的文件作版本控制 , 但实际上 , 你可以对任何类型的文件进行版本控制 , 采用版本控制系统（VCS）是个明智的选择 , 有了它你就可以将某个文件回溯到之前的状态 , 甚至将整个项目都回退到过去某个时间点的状态 , 你可以比较文件的变化细节，查出最后是谁修改了哪个地方 , 从而找出导致怪异问题出现的原因 , 又是谁在何时报告了某个功能缺陷等等 , 使用版本控制系统通常还意味着 , 就算你乱来一气把整个项目中的文件改的改删的删 , 你也照样可以轻松恢复到原先的状态 创建分支与合并首先创建分 dev 分支 , 然后切换到 dev 分支： $ git checkout -b dev Switched to a new branch ‘dev’ git checkout 命令加上 -b 参数表示创建并切换 , 相当于以下两条命令： $ git branch dev $ git checkout dev Switched to branch ‘dev’用 git branch 命令查看当前分支： $ git branch * dev master git branch 命令会列出所有分支 , 当前分支前面会标一个*号 然后在 dev 分支上正常提交 , 比如对 readme.txt 做个修改 , 加上一行： Creating a new branch is quick.提交 $ git add readme.txt $ git commit -m “branch test” [dev b17d20e] branch test 1 file changed, 1 insertion(+)现在 dev 分支工作完成 , 切换回 master 分支： $ git checkout master Switched to branch ‘master’查看 readme.txt 发现刚才添加的内容不见了 , 这是因为刚才提交的是在 dev 分支上 , 而 master 分支此刻的提交点并没发生变化 , 现在把 dev 分支的工作合并到 master 分支上 $ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge 命令用于合并指定分支到当前分支 , 合并后 , 再查看 readme.txt 的内容 , 就可以看到 ,和 dev 分支的最新提交是完全一样的 , 看上面 Fast-forward 信息 , Git 告诉我们 ,这次合并是“快进模式” , 也就是直接把 master 指向 dev 的当前提交 , 所以合并速度非常快 , 确认合并完成无误后 , 现在可以删除 dev 分支了 $ git branch -d dev Deleted branch dev (was b17d20e).再来查看 branch , 发现只剩 master 了 $ git branch * master Tips：因为创建、合并和删除分支非常快 , 所以Git鼓励你使用分支完成某个任务 , 合并后再删掉分支 , 这和直接在master分支上工作效果是一样的 , 但过程更安全 小结git branch：查看分支 git branch &lt;name&gt;：创建分支 git checkout &lt;name&gt;：切换分支 git checkout -b &lt;name&gt;：创建+切换分支 git merge &lt;name&gt;：合并某分支到当前分支 git branch -d &lt;name&gt;：删除分支 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli 安装配置]]></title>
    <url>%2F2018%2F05%2F23%2FVue-cli-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装 使用官方推荐的 webpack 点此进入 Tips：版本：node 10.1.0 , npm 5.6.0 步骤 cmd 打开命令行窗口 输入 npm install vue-cli -g , 然后回车等待(想在哪个目录建立 vue 项目就要在进入到对应目录再输入命令) 安装结束后输入 vue 如显示版本号则继续下一步操作 运行 vue init webpack demo (注：项目名称) 回车 显示 Project nanme 目录名 回车 project description 后面可以写上描述 , 或者直接回车 , Author 后面可以写作者也可以回车 Install vue-router? 选择Y 一路 n 下去 这个时候在你创建的目录下就有你的目录了 , 然后 cd 你的目录名进去 npm install 回车等待,这一步是安装依赖的 , 安装完成后会在项目文件夹下自动生成 node-module 文件来存放安装的依赖文件 , 如果这个文件夹没有那么项目是无法运行的 创建结束后在创建目录里面按住 shift+ 右键选择在此处打开命令窗口输入 npm run dev 启动应用 , 启动成功它会自动打开一个 vue 页面 每次这样启动是很麻烦的 , 用开发工具加载整个项目 , 里面有个 package.json , 包含整个项目的配置和信息的描述 , 里面有个 scripts , 这是定义的一些脚本，刚才用的就是里面的 dev , 它会执行后面的东西 , 就是用 node 跑一个 JSON 文件 在项目中 , 右击 package.json 选择 show npm scripts , 显示 npm 后 , 双击命令即可 main.js 介绍 el 是挂载点 , router 是路由 , App.vue 是整个文件的入口 , 有三部分 , template 模板 、script 逻辑、style 样式 ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 安装配置]]></title>
    <url>%2F2018%2F05%2F23%2FNode-js%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Node.js 安装配置版本：node-v 10.1.0-x64.msi , 环境：windows(X64) Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 , Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型 , 使其轻量又高效 Node.js 10.0.0 版本介绍自 Node.js Foundation 开展以来的第七个主要版本 , 并将在2018年10月成为下一个 LTS 分支 新版本自带定制化的 Node-ChakraCore 引擎 , 其功能亮点包括： 全面支持 N-API 可轻松通过新的 Visual Studio Code Extension 进行 Time-Travel 调试 支持 TTD 的生成器和异步函数 支持 Inspector 协议 增强稳定性和其他各种改进 同时包括以下更新： N-API native addons API 已从实验状态毕业 Async_hooks2.1 过时的实验性 async_hooks API 已被删除 Child Process3.1 忽略未定义的 env 属性 Console4.1 新增 console.table() 方法 Crypto5.1 crypto.createCipher() 和 crypto.createDecipher() 方法已被弃用并被 crypto.createCipheriv() 和 crypto.createDecipheriv() 替代5.2 decipher.finaltol() 方法已弃用5.3 crypto.DEFAULT_ENCODING 属性已弃用5.4 新增 ECDH.convertKey() 方法5.5 crypto.fips 属性已弃用 Dependencies6.1 V8 已升级至 6.6 版本6.2 OpenSSL 升级至 1.1.0h 版本 完整更新内容请查阅发行说明 Tips：建议梯子访问 Windows 配置 Node.js1. windows 安装包(.msi)32 位安装包下载 64 位安装包下载 2. 安装 点击 Run , 将出现如下界面 勾选接受协议选项 , 点击 next 按钮 Node.js 默认安装目录为 “C:\Program Files\nodejs\” , 也可修改目录 , 并点击 next 点击树形图标来选择安装模式 , 然后点击 next 点击 Install 开始安装 Node.js , 也可点击 Back 来修改先前的配置 , 然后点击 next 安装过程 点击 Finish 按钮退出安装向导 检查 Node.js 及 npm 版本 运行 - cmd - 输入 node --version(可简写为npm -v) , npm --version ——————————————————————————————— EOF —————————————————————————————————-]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
</search>
